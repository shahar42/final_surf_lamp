<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ocean Pulse - Live Visualization</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #00c6ff, #0072ff);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }

        .container {
            background-color: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 20px;
            padding: 40px;
            box-shadow: 0 8px 32px 0 rgba(31, 38, 135, 0.37);
            text-align: center;
        }

        h1 {
            color: #FFFCDE;
            font-size: 2em;
            margin-bottom: 10px;
            font-weight: 600;
        }

        .subtitle {
            color: rgba(255, 252, 222, 0.8);
            font-size: 0.9em;
            margin-bottom: 30px;
        }

        #surfboardCanvas {
            border-radius: 12px;
            background: rgba(0, 0, 0, 0.3);
            box-shadow: 0 0 30px rgba(0, 198, 255, 0.4);
            margin: 20px auto;
        }

        .legend {
            display: flex;
            justify-content: center;
            gap: 40px;
            margin-top: 20px;
            color: rgba(255, 252, 222, 0.9);
            font-size: 0.9em;
            font-weight: 600;
        }

        .legend span {
            text-shadow: 0 0 4px rgba(0, 0, 0, 0.8), 0 0 8px rgba(0, 0, 0, 0.6);
        }

        .wind-dir-legend {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 15px;
            margin-top: 15px;
            color: rgba(255, 252, 222, 0.8);
            font-size: 0.85em;
        }

        .wind-dir-item {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .wind-dir-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
        }

        .status {
            margin-top: 20px;
            color: rgba(255, 252, 222, 0.7);
            font-size: 0.85em;
        }

        @keyframes pulse {
            0%, 100% { opacity: 0.6; }
            50% { opacity: 1; }
        }

        .status-indicator {
            display: inline-block;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background-color: #22c55e;
            margin-right: 5px;
            animation: pulse 2s ease-in-out infinite;
        }

        .arduino-selector {
            margin: 20px 0;
        }

        .arduino-selector select {
            background: rgba(255, 255, 255, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 8px;
            padding: 10px 20px;
            color: #FFFCDE;
            font-size: 1em;
            min-width: 250px;
            cursor: pointer;
            transition: background 0.3s;
        }

        .arduino-selector select:hover {
            background: rgba(255, 255, 255, 0.25);
        }

        .arduino-selector select option {
            background: #0052cc;
            color: #FFFCDE;
            padding: 8px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üåä Ocean Pulse</h1>
        <p class="subtitle">Real-time LED animation</p>

        <div class="arduino-selector">
            <select id="locationSelect">
                <option value="">Select Location...</option>
            </select>
        </div>

        <canvas id="surfboardCanvas" width="350" height="550"></canvas>

        <div class="legend">
            <span id="periodLabel">‚Üê Wave Period</span>
            <span id="windLabel">Wind Speed</span>
            <span id="waveLabel">Wave Height ‚Üí</span>
        </div>

        <div class="wind-dir-legend">
            <span style="font-weight: 600; margin-right: 10px;">Wind Direction:</span>
            <div class="wind-dir-item"><span class="wind-dir-dot" style="background: rgb(0, 255, 0);"></span><span>N</span></div>
            <div class="wind-dir-item"><span class="wind-dir-dot" style="background: rgb(128, 255, 0);"></span><span>NE</span></div>
            <div class="wind-dir-item"><span class="wind-dir-dot" style="background: rgb(255, 255, 0);"></span><span>E</span></div>
            <div class="wind-dir-item"><span class="wind-dir-dot" style="background: rgb(255, 128, 0);"></span><span>SE</span></div>
            <div class="wind-dir-item"><span class="wind-dir-dot" style="background: rgb(255, 0, 0);"></span><span>S</span></div>
            <div class="wind-dir-item"><span class="wind-dir-dot" style="background: rgb(128, 0, 255);"></span><span>SW</span></div>
            <div class="wind-dir-item"><span class="wind-dir-dot" style="background: rgb(0, 0, 255);"></span><span>W</span></div>
            <div class="wind-dir-item"><span class="wind-dir-dot" style="background: rgb(0, 255, 255);"></span><span>NW</span></div>
        </div>

        <div class="status">
            <span class="status-indicator"></span>
            <span id="statusText">Connecting...</span>
        </div>
    </div>

    <script>
    // ==============================================
    // SURF LAMP LED VISUALIZATION - STANDALONE
    // ==============================================

    // Match Arduino hardware exactly
    const NUM_LEDS_CENTER = 20;
    const NUM_LEDS_RIGHT = 15;
    const NUM_LEDS_LEFT = 15;
    const LED_RADIUS = 8;

    // Wind direction colors (Arduino mapping)
    const WIND_DIRECTION_COLORS = {
        0: [0, 255, 0],      // N - Green
        45: [128, 255, 0],   // NE
        90: [255, 255, 0],   // E - Yellow
        135: [255, 128, 0],  // SE
        180: [255, 0, 0],    // S - Red
        225: [128, 0, 255],  // SW
        270: [0, 0, 255],    // W - Blue
        315: [0, 255, 255]   // NW - Cyan
    };

    // Color themes matching Arduino
    const COLOR_THEMES = {
        'classic_surf': {
            wave: [64, 156, 255],
            wind: [50, 255, 50],      // Green for wind speed
            period: [255, 255, 100]   // Light yellow for wave period
        },
        'ocean_breeze': {
            wave: [0, 150, 255],
            wind: [50, 255, 50],      // Green for wind speed
            period: [255, 255, 100]   // Light yellow for wave period
        },
        'day': {
            wave: [0, 150, 255],
            wind: [50, 255, 50],      // Green for wind speed
            period: [255, 255, 100]   // Light yellow for wave period
        }
    };

    let currentLocation = null;
    let currentTheme = 'classic_surf';
    let isBlinking = false;
    let blinkState = true;

    const canvas = document.getElementById('surfboardCanvas');
    const ctx = canvas.getContext('2d');
    const statusText = document.getElementById('statusText');
    const locationSelect = document.getElementById('locationSelect');

    // Fetch available locations on load
    function loadLocations() {
        fetch('/api/locations')
            .then(response => response.json())
            .then(data => {
                if (data.locations && data.locations.length > 0) {
                    data.locations.forEach(location => {
                        const option = document.createElement('option');
                        option.value = location;
                        option.textContent = location.replace(', Israel', '');
                        locationSelect.appendChild(option);
                    });

                    // Check localStorage for saved location
                    const savedLocation = localStorage.getItem('selectedLocation');

                    if (savedLocation && data.locations.includes(savedLocation)) {
                        // Use saved location if it exists in available locations
                        currentLocation = savedLocation;
                    } else {
                        // Fall back to first location
                        currentLocation = data.locations[0];
                    }

                    locationSelect.value = currentLocation;
                    fetchLampData();
                }
            })
            .catch(error => {
                console.error('Error loading locations:', error);
                statusText.textContent = 'Error loading locations';
            });
    }

    // Handle location change
    locationSelect.addEventListener('change', function() {
        currentLocation = this.value;
        if (currentLocation) {
            // Save selected location to localStorage
            localStorage.setItem('selectedLocation', currentLocation);
            statusText.textContent = `Loading ${currentLocation.replace(', Israel', '')}...`;
            fetchLampData();
        }
    });

    function getWindDirectionColor(degrees) {
        const directions = Object.keys(WIND_DIRECTION_COLORS).map(Number);
        let closest = directions[0];
        let minDiff = Math.abs(degrees - closest);

        for (let dir of directions) {
            const diff = Math.abs(degrees - dir);
            if (diff < minDiff) {
                minDiff = diff;
                closest = dir;
            }
        }

        return WIND_DIRECTION_COLORS[closest];
    }

    function drawLED(ctx, x, y, color, isLit, glow = true) {
        if (!isLit) {
            ctx.fillStyle = 'rgba(50, 50, 50, 0.3)';
            ctx.beginPath();
            ctx.arc(x, y, LED_RADIUS, 0, Math.PI * 2);
            ctx.fill();
            return;
        }

        // Glow effect
        if (glow) {
            const gradient = ctx.createRadialGradient(x, y, 0, x, y, LED_RADIUS * 2);
            gradient.addColorStop(0, `rgba(${color[0]}, ${color[1]}, ${color[2]}, 0.8)`);
            gradient.addColorStop(0.5, `rgba(${color[0]}, ${color[1]}, ${color[2]}, 0.4)`);
            gradient.addColorStop(1, `rgba(${color[0]}, ${color[1]}, ${color[2]}, 0)`);
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(x, y, LED_RADIUS * 2, 0, Math.PI * 2);
            ctx.fill();
        }

        // LED core
        ctx.fillStyle = `rgb(${color[0]}, ${color[1]}, ${color[2]})`;
        ctx.beginPath();
        ctx.arc(x, y, LED_RADIUS, 0, Math.PI * 2);
        ctx.fill();

        // Highlight
        const highlight = ctx.createRadialGradient(x - 3, y - 3, 0, x, y, LED_RADIUS);
        highlight.addColorStop(0, 'rgba(255, 255, 255, 0.8)');
        highlight.addColorStop(0.5, `rgba(${color[0]}, ${color[1]}, ${color[2]}, 0.5)`);
        highlight.addColorStop(1, `rgba(${color[0]}, ${color[1]}, ${color[2]}, 0)`);
        ctx.fillStyle = highlight;
        ctx.beginPath();
        ctx.arc(x, y, LED_RADIUS, 0, Math.PI * 2);
        ctx.fill();
    }

    function getSurfboardLEDPositions() {
        const width = canvas.width;
        const height = canvas.height;
        const centerX = width / 2;
        const spacing = 26;
        const positions = [];

        for (let i = 0; i < NUM_LEDS_CENTER; i++) {
            const y = height - 30 - (i * spacing);
            const normalizedPos = i / (NUM_LEDS_CENTER - 1);

            let widthAtPosition;
            if (normalizedPos < 0.2) {
                widthAtPosition = 30 + (normalizedPos / 0.2) * 30;
            } else if (normalizedPos < 0.4) {
                widthAtPosition = 60 + ((normalizedPos - 0.2) / 0.2) * 25;
            } else if (normalizedPos < 0.7) {
                widthAtPosition = 85;
            } else if (normalizedPos < 0.85) {
                widthAtPosition = 85 - ((normalizedPos - 0.7) / 0.15) * 35;
            } else {
                widthAtPosition = 50 - ((normalizedPos - 0.85) / 0.15) * 50;
            }

            positions.push({
                left: i < NUM_LEDS_LEFT ? {x: centerX - widthAtPosition, y: y} : null,
                center: {x: centerX, y: y},
                right: i < NUM_LEDS_RIGHT ? {x: centerX + widthAtPosition, y: y} : null
            });
        }

        return positions;
    }

    function drawSurfboard(leftLEDCount, centerLEDCount, rightLEDCount, theme, windDirColor, blink) {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        const positions = getSurfboardLEDPositions();
        const shouldBlink = blink && !blinkState;

        for (let i = 0; i < NUM_LEDS_CENTER; i++) {
            const row = positions[i];

            // Left: Wave period
            if (row.left) {
                const leftLit = (i < leftLEDCount);
                drawLED(ctx, row.left.x, row.left.y, theme.period, leftLit && !shouldBlink);
            }

            // Center: Wind speed
            if (row.center) {
                const isWindDirection = (i === NUM_LEDS_CENTER - 1);
                const isLED0 = (i === 0);

                if (isWindDirection) {
                    drawLED(ctx, row.center.x, row.center.y, windDirColor, true);
                } else if (isLED0) {
                    drawLED(ctx, row.center.x, row.center.y, theme.wind, false);
                } else {
                    const centerLit = (i <= centerLEDCount);
                    drawLED(ctx, row.center.x, row.center.y, theme.wind, centerLit && !shouldBlink);
                }
            }

            // Right: Wave height
            if (row.right) {
                const rightLit = (i < rightLEDCount);
                drawLED(ctx, row.right.x, row.right.y, theme.wave, rightLit && !shouldBlink);
            }
        }
    }

    function updateVisualization(data) {
        const theme = COLOR_THEMES[data.led_theme] || COLOR_THEMES[currentTheme];

        // Update legend colors to match theme
        document.getElementById('periodLabel').style.color = `rgb(${theme.period[0]}, ${theme.period[1]}, ${theme.period[2]})`;
        document.getElementById('windLabel').style.color = `rgb(${theme.wind[0]}, ${theme.wind[1]}, ${theme.wind[2]})`;
        document.getElementById('waveLabel').style.color = `rgb(${theme.wave[0]}, ${theme.wave[1]}, ${theme.wave[2]})`;

        // Calculate LED counts (Arduino formulas)
        const waveLEDCount = Math.max(0, Math.min(NUM_LEDS_RIGHT, Math.floor(data.wave_height_cm / 25) + 1));
        const periodLEDCount = Math.max(0, Math.min(NUM_LEDS_LEFT, Math.floor(data.wave_period_s)));
        const windLEDCount = Math.max(1, Math.min(NUM_LEDS_CENTER - 2, Math.floor(data.wind_speed_mps * 18.0 / 13.0)));

        const windDirColor = getWindDirectionColor(data.wind_direction_deg);

        // Check thresholds
        const waveThresholdExceeded = data.wave_height_cm > data.wave_threshold_cm;
        const windThresholdExceeded = data.wind_speed_mps > (data.wind_speed_threshold_knots / 1.944);

        isBlinking = waveThresholdExceeded || windThresholdExceeded;

        drawSurfboard(periodLEDCount, windLEDCount, waveLEDCount, theme, windDirColor, isBlinking);

        // Update status
        const waveM = (data.wave_height_cm / 100).toFixed(1);
        const windKts = (data.wind_speed_mps * 1.944).toFixed(1);
        statusText.textContent = `Wave: ${waveM}m | Wind: ${windKts}kts | Period: ${data.wave_period_s.toFixed(1)}s`;
    }

    function fetchLampData() {
        if (!currentLocation) {
            return;
        }

        fetch(`/api/lamp-by-location/${encodeURIComponent(currentLocation)}`)
            .then(response => response.json())
            .then(data => {
                if (data.data_available) {
                    updateVisualization(data);
                } else {
                    statusText.textContent = data.message || 'No data available';
                }
            })
            .catch(error => {
                console.error('Error fetching lamp data:', error);
                statusText.textContent = 'Connection error - retrying...';
            });
    }

    function blinkLoop() {
        if (isBlinking) {
            blinkState = !blinkState;
        } else {
            blinkState = true;
        }
    }

    // Start
    loadLocations(); // This will auto-fetch first location's data
    setInterval(fetchLampData, 780000); // 13 minutes
    setInterval(blinkLoop, 800); // Blink animation
    </script>
</body>
</html>
