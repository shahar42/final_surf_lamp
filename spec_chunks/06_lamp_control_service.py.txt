Create file: app/business_logic/services/lamp_control_service.py

GENERATE PYTHON CODE implementing ILampControlService from shared.contracts:

from shared.contracts import (
    ILampControlService, ILampRepository, ISurfDataProvider, 
    ICacheManager, IActivityLogger, IPasswordSecurity, IInputValidator,
    ArduinoResponse, LampConfig, SurfData,
    LampNotFoundError, ValidationError
)
from typing import Dict, Any, Optional
import logging
import time

logger = logging.getLogger(__name__)

class LampControlService(ILampControlService):
    def __init__(
        self,
        lamp_repo: ILampRepository,
        surf_provider: ISurfDataProvider,
        cache_manager: ICacheManager,
        activity_logger: IActivityLogger,
        password_security: IPasswordSecurity,
        validator: IInputValidator
    ):
        self.lamp_repo = lamp_repo
        self.surf_provider = surf_provider
        self.cache_manager = cache_manager
        self.activity_logger = activity_logger
        self.password_security = password_security
        self.validator = validator

    async def get_lamp_configuration_data(self, lamp_id: str) -> ArduinoResponse:
        '''Get lamp config and surf data, return Arduino format'''
        try:
            # Validate lamp_id
            if not await self.validator.validate_lamp_id(lamp_id):
                raise ValidationError(f"Invalid lamp ID: {lamp_id}")
            
            # Get lamp configuration
            lamp_config = await self.lamp_repo.get_lamp_configuration(lamp_id)
            
            if not lamp_config:
                # Return unregistered response
                response = ArduinoResponse()
                response.update({
                    "registered": False,
                    "brightness": 50,
                    "location_used": "",
                    "wave_height_m": None,
                    "wave_period_s": None,
                    "wind_speed_mps": None,
                    "wind_deg": None,
                    "error": "Lamp not registered. Visit setup portal."
                })
                await self.activity_logger.log_activity(
                    lamp_id, "config_request", "unregistered", None
                )
                return response
            
            # Get surf data
            location_index = lamp_config.get("location_index", 0)
            surf_data = await self._get_surf_data_with_cache(location_index)
            
            # Create response
            response = ArduinoResponse()
            response.update({
                "registered": True,
                "brightness": lamp_config.get("brightness", 100),
                "location_used": lamp_config.get("location_name", ""),
                "wave_height_m": surf_data.get("wave_height_m") if surf_data else None,
                "wave_period_s": surf_data.get("wave_period_s") if surf_data else None,
                "wind_speed_mps": surf_data.get("wind_speed_mps") if surf_data else None,
                "wind_deg": surf_data.get("wind_deg") if surf_data else None,
                "error": None if surf_data else "Surf data temporarily unavailable"
            })
            
            await self.activity_logger.log_activity(
                lamp_id, "config_request", "success", 
                {"location": lamp_config.get("location_name")}
            )
            
            return response
            
        except ValidationError:
            raise
        except Exception as e:
            logger.error(f"Error getting lamp config: {e}")
            response = ArduinoResponse()
            response["error"] = "System error occurred"
            return response
    
    async def _get_surf_data_with_cache(self, location_index: int) -> Optional[SurfData]:
        '''Get surf data with caching'''
        # Check cache first
        cached_data = await self.cache_manager.get_surf_data_cache(location_index)
        
        if cached_data and self._is_data_fresh(cached_data):
            logger.info(f"Cache hit for location {location_index}")
            return cached_data
        
        # Fetch fresh data
        try:
            fresh_data = await self.surf_provider.fetch_surf_data(location_index)
            if fresh_data:
                await self.cache_manager.set_surf_data_cache(
                    location_index, fresh_data, ttl_seconds=1800
                )
                return fresh_data
        except Exception as e:
            logger.error(f"Failed to fetch fresh data: {e}")
        
        # Return stale cache if available
        return cached_data
    
    def _is_data_fresh(self, data: SurfData, max_age_minutes: int = 30) -> bool:
        '''Check if cached data is fresh'''
        if not data or "timestamp" not in data:
            return False
        age = (time.time() - data["timestamp"]) / 60
        return age < max_age_minutes
    
    async def process_user_registration(self, registration_data: Dict[str, Any]) -> Dict[str, Any]:
        '''Process user registration'''
        try:
            # Validate all inputs
            is_valid = all([
                await self.validator.validate_email(registration_data.get("email", "")),
                await self.validator.validate_lamp_id(registration_data.get("lamp_id", "")),
                await self.validator.validate_location_index(registration_data.get("location_index", -1))
            ])
            
            if not is_valid:
                return {"success": False, "message": "Validation failed"}
            
            # Hash password
            password_hash = await self.password_security.hash_password(
                registration_data["password"]
            )
            
            # Register lamp
            registration_data["password_hash"] = password_hash
            success = await self.lamp_repo.register_new_lamp(registration_data)
            
            return {
                "success": success,
                "message": "Registration successful" if success else "Registration failed"
            }
            
        except Exception as e:
            logger.error(f"Registration error: {e}")
            return {"success": False, "message": str(e)}