API Layer Complete Specification
===============================

DOMAIN RESPONSIBILITY: FastAPI endpoints, HTTP handling, request/response validation
FORBIDDEN: Database access, business logic, external API calls, caching implementation

INTERFACE CONTRACTS TO CONSUME:
===============================

From shared.contracts import:
- ILampControlService (business logic delegation)
- IInputValidator (input validation)
- ArduinoResponse (critical response format)
- LampNotFoundError, ValidationError (error types)
- validate_arduino_response (response validation function)

REQUIRED DIRECTORY STRUCTURE:
============================

Create these files:
```
app/api/
├── main.py                    # FastAPI app setup
├── dependencies.py            # Dependency injection
├── middleware.py             # CORS and logging middleware
├── models.py                 # Pydantic request models
└── routers/
    ├── lamp_router.py        # Arduino endpoints
    ├── user_router.py        # Registration endpoints
    └── health_router.py      # Health check endpoints
```

CRITICAL ENDPOINT SPECIFICATIONS:
=================================

1. ARDUINO CONFIGURATION ENDPOINT (MISSION CRITICAL)
   --------------------------------------------------
   
   Route: GET /api/v1/lamps/{lamp_id}/config
   
   Purpose: Called by Arduino devices every 10 minutes for surf data
   
   Implementation Requirements:
   - Use dependency injection: lamp_service: ILampControlService = Depends()
   - Call: await lamp_service.get_lamp_configuration_data(lamp_id)
   - MUST validate response using validate_arduino_response() function
   - Return ArduinoResponse format EXACTLY (Arduino firmware depends on this)
   
   Error Handling:
   - LampNotFoundError -> HTTP 404 "Lamp not found"
   - ValidationError -> HTTP 400 "Invalid lamp ID"
   - Invalid response format -> HTTP 500 "Response format error"
   - Any other exception -> HTTP 500 "Internal server error"
   
   Response Format (IMMUTABLE):
   ```json
   {
       "registered": bool,
       "brightness": int,
       "location_used": str,
       "wave_height_m": float | null,
       "wave_period_s": float | null,
       "wind_speed_mps": float | null,
       "wind_deg": int | null,
       "error": str | null
   }
   ```

2. USER REGISTRATION ENDPOINT
   --------------------------
   
   Route: POST /api/v1/register
   
   Purpose: Register new users and lamps from web interface
   
   Request Model (Pydantic):
   ```python
   class UserRegistrationRequest(BaseModel):
       name: str = Field(min_length=1, max_length=100)
       email: EmailStr
       password: str = Field(min_length=8)
       lamp_id: str = Field(min_length=3, max_length=50)
       location_index: int = Field(ge=0, le=4)
   ```
   
   Implementation Requirements:
   - Inject: validator: IInputValidator = Depends()
   - Inject: lamp_service: ILampControlService = Depends()
   - Validate ALL inputs using validator methods (await calls)
   - Delegate to: await lamp_service.process_user_registration(request.dict())
   - Return success message or detailed validation errors
   
   Error Handling:
   - ValidationError -> HTTP 400 with specific field errors
   - Duplicate registration -> HTTP 409 "User already exists"
   - Any other exception -> HTTP 500 "Registration failed"

3. HEALTH CHECK ENDPOINTS
   -----------------------
   
   Route: GET /health
   Purpose: Simple health check for load balancer
   Implementation: Return {"status": "healthy"} immediately
   
   Route: GET /ready
   Purpose: Readiness check with dependency validation
   Implementation: 
   - Try to inject ILampControlService and IInputValidator
   - If successful: Return {"status": "ready"}
   - If failed: Return HTTP 503 {"status": "not ready"}

DEPENDENCY INJECTION SETUP:
===========================

File: app/api/dependencies.py

Requirements:
- Import interfaces from shared.contracts
- Import concrete implementations from business_logic and infrastructure domains
- Provide factory functions for dependency injection
- Handle initialization of services with required dependencies

Example pattern:
```python
def get_lamp_service() -> ILampControlService:
    # Import and initialize concrete implementation
    # Wire up with required dependencies (repos, cache, etc.)
    return concrete_service_instance

def get_input_validator() -> IInputValidator:
    # Import and return concrete validator
    return concrete_validator_instance
```

MIDDLEWARE REQUIREMENTS:
=======================

File: app/api/middleware.py

Required Middleware:
1. CORS Middleware:
   - Allow origins: ["*"] for development, configurable for production
   - Allow all methods and headers
   - Enable credentials if needed

2. Request Logging Middleware:
   - Log all incoming requests with: method, path, query params
   - Log response status and duration
   - Use structured logging (JSON format)
   - Include correlation IDs for request tracing

3. Error Handling Middleware:
   - Catch unhandled exceptions
   - Return consistent error format
   - Log errors with full context
   - Never expose internal details to clients

FASTAPI APPLICATION SETUP:
==========================

File: app/api/main.py

Requirements:
- Create FastAPI app with title "Surfboard Lamp Backend"
- Set up all middleware in correct order
- Include all routers with appropriate prefixes:
  - lamp_router: prefix="/api/v1/lamps"
  - user_router: prefix="/api/v1"
  - health_router: prefix="" (root level)
- Configure OpenAPI documentation
- Set up lifespan events if needed for cleanup

REQUEST/RESPONSE MODELS:
=======================

File: app/api/models.py

Required Models:
1. UserRegistrationRequest (detailed above)
2. UserRegistrationResponse:
   ```python
   class UserRegistrationResponse(BaseModel):
       success: bool
       message: str
       errors: Optional[List[str]] = None
   ```
3. HealthCheckResponse:
   ```python
   class HealthCheckResponse(BaseModel):
       status: str
       timestamp: Optional[str] = None
   ```

VALIDATION PATTERNS:
===================

Input Validation Strategy:
- Use IInputValidator for business rule validation
- Use Pydantic for format/type validation
- Combine both for comprehensive validation
- Always use await for validator calls (they're async)

Example Validation Flow:
```python
# 1. Pydantic handles format validation automatically
request: UserRegistrationRequest  # Validates types, required fields

# 2. Business validation using IInputValidator
is_valid_email = await validator.validate_email(request.email)
is_valid_lamp = await validator.validate_lamp_id(request.lamp_id)
is_valid_location = await validator.validate_location_index(request.location_index)

# 3. Raise ValidationError if any validation fails
if not all([is_valid_email, is_valid_lamp, is_valid_location]):
    raise ValidationError("Validation failed")
```

LOGGING REQUIREMENTS:
====================

Logging Strategy:
- Use structured logging (JSON format)
- Include correlation IDs for request tracing
- Log at appropriate levels:
  - INFO: Successful operations
  - WARNING: Validation failures
  - ERROR: System errors
  - DEBUG: Detailed debugging info

Required Log Fields:
- timestamp
- level
- message
- request_id
- endpoint
- method
- status_code
- duration_ms
- user_context (if available)

ERROR RESPONSE FORMAT:
=====================

Standardized Error Response:
```python
{
    "error": {
        "code": "VALIDATION_ERROR",
        "message": "Human readable message",
        "details": ["Specific field errors"],
        "timestamp": "2025-01-01T00:00:00Z"
    }
}
```

HTTP Status Code Mapping:
- 200: Success
- 201: Created (registration)
- 400: Bad Request (validation errors)
- 404: Not Found (lamp not found)
- 409: Conflict (duplicate registration)
- 500: Internal Server Error
- 503: Service Unavailable (readiness check fail)

CRITICAL SUCCESS CRITERIA:
=========================

The API layer implementation MUST:
✅ Return ArduinoResponse format exactly (validate with validate_arduino_response)
✅ Use dependency injection for all cross-domain communication
✅ Handle all error scenarios gracefully with appropriate HTTP status codes
✅ Validate all inputs using both Pydantic and IInputValidator
✅ Never contain business logic or database access
✅ Log all operations with structured logging
✅ Include comprehensive error handling and user-friendly error messages
✅ Support Arduino devices with reliable 10-minute polling
✅ Provide health checks for monitoring and load balancing

INTEGRATION TESTING REQUIREMENTS:
=================================

The generated API layer should be testable with:
- Mock implementations of ILampControlService and IInputValidator
- Arduino response format validation tests
- HTTP status code verification
- Error handling scenario testing
- Request/response schema validation

Generate complete, production-ready FastAPI application following these specifications.
