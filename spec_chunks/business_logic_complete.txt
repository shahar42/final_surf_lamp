Business Logic Layer Complete Specification
==========================================

DOMAIN RESPONSIBILITY: Service orchestration, LangChain agents, business rules, background scheduling
FORBIDDEN: Direct database access, HTTP handling, external API implementation, cache implementation

INTERFACE CONTRACTS TO IMPLEMENT:
=================================

YOU MUST IMPLEMENT these interfaces:

1. ILampControlService - Main business logic coordination
2. IBackgroundScheduler - 30-minute surf data refresh cycle

INTERFACE CONTRACTS TO CONSUME:
===============================

From shared.contracts import:
- ILampRepository, IUserRepository, IActivityLogger (data layer)
- ISurfDataProvider (infrastructure layer)
- ICacheManager (data layer)
- IPasswordSecurity, IInputValidator (infrastructure layer)
- ArduinoResponse, SurfData, LampConfig (data types)
- All error types: LampNotFoundError, ValidationError, etc.

REQUIRED DIRECTORY STRUCTURE:
============================

Create these files:
```
app/business_logic/
├── services/
│   ├── lamp_control_service.py    # ILampControlService implementation
│   └── background_scheduler.py    # IBackgroundScheduler implementation
├── agents/
│   ├── surf_lamp_coordinator.py   # Main LangChain agent
│   └── data_refresh_agent.py      # Background data agent
└── workflows/
    ├── lamp_configuration_workflow.py
    └── user_registration_workflow.py
```

CRITICAL BUSINESS LOGIC SPECIFICATIONS:
=======================================

1. LAMP CONTROL SERVICE (CORE BUSINESS LOGIC)
   -------------------------------------------

   Class: LampControlService(ILampControlService)
   
   Primary Method: get_lamp_configuration_data(lamp_id: str) -> ArduinoResponse
   
   Business Logic Flow:
   ```
   1. Validate lamp_id format using IInputValidator
   2. Get lamp configuration from ILampRepository
   3. If lamp not found -> return unregistered ArduinoResponse
   4. Extract location_index from lamp configuration
   5. Try to get cached surf data from ICacheManager
   6. If cache hit and fresh (< 30 min) -> use cached data
   7. If cache miss -> fetch from ISurfDataProvider
   8. If fetch succeeds -> update cache and continue
   9. If fetch fails -> use stale cache or return error response
   10. Format complete ArduinoResponse with all data
   11. Log activity using IActivityLogger
   12. Return ArduinoResponse
   ```
   
   Error Handling Strategy:
   - Invalid lamp_id -> raise ValidationError
   - Lamp not in database -> return unregistered response (not an error)
   - Surf data unavailable -> return response with error field populated
   - Database errors -> raise DatabaseError
   - Never let exceptions reach API layer unhandled
   
   Implementation Requirements:
   - Use dependency injection for all services
   - Never import concrete implementations
   - All operations must be async
   - Comprehensive logging at each step
   - Cache surf data with 30-minute TTL
   - Handle multiple API provider failures gracefully

   Secondary Method: process_user_registration(registration_data: Dict[str, Any]) -> Dict[str, Any]
   
   Registration Business Logic:
   ```
   1. Validate all input fields using IInputValidator
   2. Hash password using IPasswordSecurity
   3. Check for duplicate user/lamp using IUserRepository
   4. Create user record in database
   5. Create lamp record with location mapping
   6. Log registration activity
   7. Return success/failure status with details
   ```

2. BACKGROUND SCHEDULER SERVICE
   -----------------------------
   
   Class: SurfDataScheduler(IBackgroundScheduler)
   
   Purpose: Periodic surf data refresh every 30 minutes
   
   Implementation Requirements:
   - Use APScheduler with AsyncIOScheduler
   - Job interval: 30 minutes exactly
   - Maximum instances: 1 (prevent overlapping runs)
   - Graceful startup and shutdown
   
   Method: start_surf_data_updates() -> None
   ```
   1. Initialize AsyncIOScheduler
   2. Add periodic job with 30-minute interval
   3. Start scheduler
   4. Log scheduler startup
   ```
   
   Method: stop_scheduler() -> None
   ```
   1. Gracefully shutdown scheduler
   2. Wait for current job completion
   3. Log scheduler shutdown
   ```
   
   Background Job Logic:
   ```
   1. Get all unique location_indexes from active lamps (ILampRepository)
   2. For each unique location:
      a. Fetch fresh surf data from ISurfDataProvider
      b. Update cache with new data (ICacheManager)
      c. Log success/failure for monitoring
   3. Handle individual location failures without stopping entire job
   4. Log job completion with statistics
   ```

LANGCHAIN AGENT ARCHITECTURE:
============================

1. SURF LAMP COORDINATOR AGENT
   ----------------------------
   
   Class: SurfLampCoordinator
   
   Purpose: Orchestrate complex lamp configuration workflows using LangChain
   
   Agent Tools:
   - DatabaseTool: Lamp configuration retrieval and updates
   - SurfDataTool: External API coordination and fallback logic
   - CacheTool: Intelligent caching operations
   - LoggingTool: Activity tracking and monitoring
   
   LangChain Configuration:
   ```python
   tools = [
       Tool(
           name="get_lamp_config",
           description="Retrieve lamp configuration from database",
           func=self._get_lamp_configuration_tool
       ),
       Tool(
           name="fetch_surf_data", 
           description="Get surf data with caching and fallback",
           func=self._fetch_surf_data_tool
       ),
       Tool(
           name="log_activity",
           description="Log lamp activities for monitoring",
           func=self._log_activity_tool
       )
   ]
   
   agent = create_react_agent(llm, tools, prompt_template)
   ```
   
   Agent Workflow for Lamp Configuration:
   ```
   INPUT: lamp_id
   
   THOUGHT: I need to get the lamp configuration and current surf data
   ACTION: get_lamp_config with lamp_id
   OBSERVATION: Lamp found with location_index 2 (Honolulu)
   
   THOUGHT: Now I need fresh surf data for Honolulu
   ACTION: fetch_surf_data with location_index 2
   OBSERVATION: Fresh surf data retrieved: wave_height=1.8m, wind=15kph
   
   THOUGHT: I have all data needed to create Arduino response
   FINAL ANSWER: Complete ArduinoResponse with all fields populated
   ```

2. DATA REFRESH AGENT
   -------------------
   
   Class: DataRefreshAgent
   
   Purpose: Background data refresh coordination using LangChain
   
   Agent Tools:
   - LocationTool: Get all active lamp locations
   - ProviderTool: Coordinate multiple API providers
   - CacheUpdateTool: Update cache with fresh data
   - MonitoringTool: Track refresh success/failure rates
   
   Background Workflow:
   ```
   SCHEDULED: Every 30 minutes
   
   THOUGHT: Time to refresh surf data for all active locations
   ACTION: get_active_locations
   OBSERVATION: Found 3 unique locations: [0, 1, 2]
   
   FOR EACH LOCATION:
     THOUGHT: Need fresh data for location {index}
     ACTION: fetch_from_providers with location {index}
     OBSERVATION: Data retrieved from provider X
     ACTION: update_cache with fresh data
     OBSERVATION: Cache updated successfully
   
   FINAL: All locations refreshed, statistics logged
   ```

SERVICE ORCHESTRATION PATTERNS:
==============================

1. DEPENDENCY INJECTION PATTERN
   -----------------------------
   
   ```python
   class LampControlService(ILampControlService):
       def __init__(self,
                    lamp_repo: ILampRepository,
                    user_repo: IUserRepository,
                    surf_provider: ISurfDataProvider,
                    cache_manager: ICacheManager,
                    activity_logger: IActivityLogger,
                    password_security: IPasswordSecurity,
                    validator: IInputValidator):
           self.lamp_repo = lamp_repo
           self.user_repo = user_repo
           self.surf_provider = surf_provider
           self.cache_manager = cache_manager
           self.activity_logger = activity_logger
           self.password_security = password_security
           self.validator = validator
   ```

2. ERROR HANDLING PATTERN
   -----------------------
   
   ```python
   async def get_lamp_configuration_data(self, lamp_id: str) -> ArduinoResponse:
       try:
           # Validate input
           if not await self.validator.validate_lamp_id(lamp_id):
               raise ValidationError(f"Invalid lamp ID: {lamp_id}")
           
           # Get lamp config
           lamp_config = await self.lamp_repo.get_lamp_configuration(lamp_id)
           if not lamp_config:
               await self.activity_logger.log_activity(
                   lamp_id, "config_request", "lamp_not_found", None
               )
               return self._create_unregistered_response()
           
           # Get surf data with fallback logic
           surf_data = await self._get_surf_data_with_fallback(
               lamp_config["location_index"]
           )
           
           # Create response
           response = self._create_registered_response(lamp_config, surf_data)
           
           # Log success
           await self.activity_logger.log_activity(
               lamp_id, "config_request", "success", 
               {"location": lamp_config.get("location_name")}
           )
           
           return response
           
       except ValidationError:
           raise  # Re-raise validation errors
       except Exception as e:
           # Log unexpected errors
           await self.activity_logger.log_activity(
               lamp_id, "config_request", "error", {"error": str(e)}
           )
           # Return safe error response
           return self._create_error_response("System error occurred")
   ```

3. CACHING STRATEGY PATTERN
   -------------------------
   
   ```python
   async def _get_surf_data_with_fallback(self, location_index: int) -> Optional[SurfData]:
       # Try cache first
       cached_data = await self.cache_manager.get_surf_data_cache(location_index)
       
       if cached_data and self._is_data_fresh(cached_data, max_age_minutes=30):
           logger.info("Cache hit", location_index=location_index)
           return cached_data
       
       # Cache miss or stale - fetch fresh data
       try:
           fresh_data = await self.surf_provider.fetch_surf_data(location_index)
           if fresh_data:
               # Update cache with fresh data
               await self.cache_manager.set_surf_data_cache(
                   location_index, fresh_data, ttl_seconds=1800
               )
               logger.info("Fresh data cached", location_index=location_index)
               return fresh_data
       except Exception as e:
           logger.warning("Fresh data fetch failed", 
                         location_index=location_index, error=str(e))
       
       # Return stale cache if available, or None
       if cached_data:
           logger.info("Using stale cache", location_index=location_index)
           return cached_data
       
       return None
   ```

ARDUINO RESPONSE FORMATTING:
============================

Response Creation Methods:

1. Unregistered Response:
   ```python
   def _create_unregistered_response(self) -> ArduinoResponse:
       response = ArduinoResponse()
       response.update({
           "registered": False,
           "brightness": 50,
           "location_used": "",
           "wave_height_m": None,
           "wave_period_s": None,
           "wind_speed_mps": None,
           "wind_deg": None,
           "error": "Lamp not registered. Visit setup portal."
       })
       return response
   ```

2. Registered Response with Data:
   ```python
   def _create_registered_response(self, lamp_config: LampConfig, 
                                 surf_data: Optional[SurfData]) -> ArduinoResponse:
       response = ArduinoResponse()
       response.update({
           "registered": True,
           "brightness": lamp_config.get("brightness", 100),
           "location_used": lamp_config.get("location_name", ""),
           "wave_height_m": surf_data.get("wave_height_m") if surf_data else None,
           "wave_period_s": surf_data.get("wave_period_s") if surf_data else None,
           "wind_speed_mps": surf_data.get("wind_speed_mps") if surf_data else None,
           "wind_deg": surf_data.get("wind_deg") if surf_data else None,
           "error": None if surf_data else "Surf data temporarily unavailable"
       })
       return response
   ```

MONITORING AND OBSERVABILITY:
=============================

Business Logic Metrics:
- Lamp configuration request rate
- Surf data cache hit/miss ratio
- Background job success/failure rate
- API provider performance and fallback usage
- Registration success rate

Activity Logging Strategy:
```python
# Log all business operations
await self.activity_logger.log_activity(
    lamp_id=lamp_id,
    activity_type="config_request",  # config_request, registration, background_refresh
    status="success",  # success, failure, warning
    details={
        "location": location_name,
        "cache_hit": True,
        "provider_used": "surfline",
        "response_time_ms": 150
    }
)
```

CRITICAL SUCCESS CRITERIA:
=========================

The business logic layer MUST:
✅ Implement ILampControlService with complete Arduino response logic
✅ Implement IBackgroundScheduler with 30-minute refresh cycle
✅ Use dependency injection for ALL cross-domain communication
✅ Never import concrete implementations from other domains
✅ Handle all error scenarios without exposing internal details
✅ Cache surf data efficiently with TTL management
✅ Log all business operations for monitoring
✅ Coordinate between multiple external API providers
✅ Process user registrations with complete validation
✅ Use LangChain agents for complex workflow orchestration
✅ Maintain high availability with graceful degradation
✅ Support Arduino devices with reliable data delivery

INTEGRATION REQUIREMENTS:
========================

Service Initialization:
- All services must be configurable through dependency injection
- No hardcoded dependencies on concrete implementations
- Support for testing with mock dependencies
- Graceful startup and shutdown procedures

Performance Requirements:
- Lamp configuration requests: < 500ms response time
- Cache operations: < 50ms
- Background job completion: < 5 minutes for all locations
- Memory efficient with proper resource cleanup

Generate complete, production-ready business logic services following these specifications.
